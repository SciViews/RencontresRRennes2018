---
title: "Rencontres R - Rennes 2018 - `chart` et `flow` mini-tutorial"
output: html_notebook
---

Version commentée et augmentée de RRennes2018_presentation.Rmd.


## Installation

La versions en développement sur Github de ces fonctions est nécessaire :

```{r}
#install.packages("devtools")
##install.packages(c("tidyverse", "latticeExtra", "cowplot",
#  "pryr", "ggpubr", "ggplotify", "svMisc", "proto", "tsibble",
#  "Hmisc", "nycflights13"))
#devtools::install_github("SciViews/data")
#devtools::install_github("SciViews/chart")
#devtools::install_github("SciViews/flow")
#
#library(tidyverse)
#library(data)
#library(chart)
#library(flow)
#
#ou plus simplement, lorsque la prichaine version SciViews sera sur CRAN :
#install.packages("Sciviews")
SciViews::R
```

Nous utiliserons le jeu de données `urchin_bio` du package `data`, avec annotation (`label` et `units`) en français. Cela se fait avec la fonction `read()` du package `data` :

```{r}
urchin <- data::read("urchin_bio", package = "data", lang = "FR")
```

Ce jeu de données contient diverses mesures de biométrie sur deux populations d'oursins : ceux provenant d'élevage ("Culture") et ceux provenant du milieu naturel ("Pêcherie").


## Pourquoi utiliser `read()` à la place de `data()` pour charger un package R ?

- Difficultés ches les débutants entre `data(<dataset>)` et `<df> <- read.csv("<filepath>", <args>)` : "patterns" différents.

- dans **data**, pattern similaire:

`<df> <- read("<dataset>", <args>)`

deux cas:

- jeu de données d'un package R:

`<df> <- read("<dataset_name>", package = "<pkg>")`

- fichier:

`<df> <- read("<dataset_file>", <args>)`

- Possibilité d'annoter les variables (attributs `label` et `units`) dans différentes langues. Cette information sera utilisée par `chart()` plus tard.

```{r}
#View(urchin) # Les labels apparaissent dans RStudio
attributes(urchin$skeleton) # Label et unités enregistrés
```


## Utilisation de `chart`

Masse squelettique des oursins en fonction de la masse totale?

```{r}
ggplot(data = urchin, aes(weight, skeleton)) +
  geom_point()
```

Patterns: les premiers graphes que les étudiants voient s'impriment dans leur esprit comme les exemples à suivre. `ggplot2` produit des graphes très proches d'un idéal, mais:

- thème par défaut particulier (fond gris)
- mauvais libellé des axes et unités manquantes

=> Utiliser un autre thème par défaut
=> Prendre en compte le label et les unités enregistrés dans le jeu de données

=> chart(). Remplacement mininal de la syntaxe `ggplot()`

**Règle `chart()` #1:** `chart()`peut remplacer `ggplot()` sans changer le reste.

```{r}
chart(data = urchin, aes(weight, skeleton)) +
  geom_point()
```


### Interface formule

Effectuons une régression linéaire :

```{r}
(lmod <- lm(data = urchin, skeleton ~ weight))
```

Patterns différents avec position des variables x et y inversées:

`aes(<x>, <y>)` _versus_ `<y> ~ <x>` => source de confusion et d'erreur!

**Règle `chart()` #2 :** `f_aes()` à la place de `aes()`, permettant de spécifier les "aesthetics" via des formules.

```{r}
ggplot(data = urchin, f_aes(skeleton ~ weight)) +
  geom_point()
```

Combiné avec la règle #1, `chart()` à la place de `ggplot()`, plus besoin de préciser `f_aes()` !

```{r}
chart(data = urchin, skeleton ~ weight) +
  geom_point()
```

On a donc maintenant exactement le même pattern pour `lm(data = <df>, <formula>)` et `chart(data = <df>, <formula>)`. Plus facile pour les débutants.


### Versions différentes de graphiques

**Règle `chart` #3 :** `chart()` est "subsettable" pour indiquer le type de graphique à réaliser : `chart$<type>`()

```{r}
chart$geom_point(data = urchin, skeleton ~ weight)
```

Il prend en compte également les graphiques `lattice`s ou de base. Notez la similitude.

```{r}
chart$xyplot(data = urchin, skeleton ~ weight)
```

**Travail en cours :** prise en compte automatique des labels et du thème, similaire à celui pour `ggplot2`.


### Paramètres additionnels directement dans les formules

Exemple, couleur en fonction de l'origine.

```{r}
chart$geom_point(data = urchin, f_aes(skeleton ~ weight, col = origin))
```

**Règle `chart` #4 :** arguments supplémentaires `aes()` directement intégrable dans la formule à l'aide de la syntaxe `%<par>=%`.

```{r}
chart$geom_point(data = urchin, skeleton ~ weight %col=% origin)
```

La syntaxe `|` est également reconnue pour les "facets" :

```{r}
chart$geom_point(data = urchin, skeleton ~ weight | origin)
```

... et toujours similaire à lattice :

```{r}
chart$xyplot(data = urchin, skeleton ~ weight | origin)
```

Il est facile d'ajouter la droite de régression dans son graphique :

```{r}
chart$geom_point(data = urchin, skeleton ~ weight) +
  geom_smooth(method = "lm")
```


### Compatibilité 

**Autre source d'erreur chez les débutants :** l'incompatibilité complète entre les graphiques de base, `lattice` et `ggplot2`. Si l'étudiant effectue une analyse des résidus, il peut faire :

```{r}
par(mfrow = c(1L, 2L))
plot(urchin_lm, which = 1L)
plot(urchin_lm, which = 2L)
```

Mais si il veut reprendre le graphe `ggplot2` et l'associer à ces deux graphiques dans une figure composite, ce n'est pas possible !

Avec `chart()`, tous les graphiques peuvent être agencés ensemble quelle que soit leur nature.

```{r}
c# ggplot2
c1 <- chart$geom_point(data = urchin, skeleton ~ weight) +
  geom_smooth(method = "lm")
# Lattice plot
c2 <- chart$xyplot(data = urchin, skeleton ~ weight | origin)
# Base plots
c3 <- chart$plot(lmod, which = 1L)
c4 <- chart$plot(lmod, which = 2L)

ggarrange(c1, c2, c3, c4, labels = "AUTO")
```


## Utilisation de `flow`

Combinaison de briques logicielles avec l'opérateur "pipe". Facilite l'assemblage de briques logicielles pour réaliszr des tâches plus complexes tout en gardant un code lisible.

Difficultés lorsque l'on veut généraliser le pipeline (à l'intérieur d'une fonction).

Partons d'un exemple simple :

```{r}
urchin %>%
  mutate(lgsk = log(skeleton)) %>%
  summarise(mean = mean(lgsk,
    na.rm = TRUE))
```

On a trois arguments qu'on voudrait pouvoir modifier pour généraliser ce pipeline (du plus facile au plus complexe) :

- Un argument qui demande une constante `TRUE`/`FALSE` (la valeur pour `na.rm=`), que l'on nommera `na_rm` et qui ne nécessite pas de passer par une `quosure`.

- Une variable qui contient une expression à passer sous forme d'une `quosure` à débaler à l'intérieur du pipeline dans l'expression non standard prise par la fonction `mutate()` (qu'on nommera `x`)

- Une variable qui sert de nom dans `mutate()` et ensuite est utilisée plus loin dans le pipeline, à passer aussi sous forme de `quosure` dans une autre expression non standard dans `summarise()` (qu'on nommera `y`) 

Nous allons effectuer ces rempl  acement successivement à l'aide de `tidyverse` d'abord, et ensuite, en utilisant `flow`.


### Variable ne nécessitant pas de `quosure`

Dans `tidyverse` :

```{r}
na_rm <- TRUE
urchin %>%
  mutate(lgsk = log(skeleton)) %>%
  summarise(mean = mean(lgsk,
    na.rm = !!na_rm))
```

On notera deux choses :

- Il n'y a aucune place dans le pipeline pour la variable `na_rm`. Donc, on doit la stocker ailleurs (ici, dans notre environnement global). C'est pas idéal.

- Pour injecter sa valeur dans l'expression non standard, argument de `summarise()`, il faut utiliser l'opérateur préfixe "lazyeval" `!!` (prononcez "bang bang") devant notre variable `na_rm`.


#### Variable dans `flow`

Nous allons modifier légèrement le pipeline pour créer et ensuite transmettre d'une étape à l'autre les données dans un objet appelé `flow`. Dans cet objet, on peut rajouter des variables satellites. La modification nécessite :

- d'utiliser la fonction `flow()` qui prend un premier argument avec les données à traiter, et éventuellement autant d'autres variables que vous voulez,

- de remplacer l'opérateur de pipe `%>%` de `magrittr` (`tidyverse`) par `%>_%` du package `flow`. Ce dernier opérateur est capable de gérer les particularités de l'objet `flow` au travers du pipeline,

- de terminer le pipeline par `%>_% .` qui va permettre d'extraire le résultat final (sinon, on se retrouve avec le dernier objet `flow` qui contient ce résultat final).

- ... et bien sûr, on rajoute ici la variable `na_rm` :

```{r}
flow(urchin, na_rm = TRUE) %>_%
  mutate(., lgsk = log(skeleton)) %>_%
  summarise(., mean = mean(lgsk,
    na.rm = na_rm_)) %>_% .
```

Les plus attentifs auront noté une autre différence. Au lieu de `!!na_rm` dans l'expression non standard dans `summarise()`, on a utilisé `na_rm_`. Donc, l'opérateur `!!` de "tidyeval" est remplacé par un **"opérateur" suffixé** `_` derrière la variable `na_rm`. Opérateur est entre guillement, car syntactiquement parlant, ce n'en est pas une, mais il se comportera comme tel. Son rôle est de :

1) extraire l'objet associé au nom `na_rm` depuis l'objet `flow`, et

2) l'injecter dans l'expression non standard donnée à `summarise()` (mécanisme "tidyeval").


### Variable nécessitant une `quosure`

Revenons à notre pipeline `tidyverse` où on veut créer la variable `x` qui spécifie la variable du tableau à traiter (`skeleton` ou autre). En `tidyverse`, on écrira :

```{r}
x <- quo(skeleton)
na_rm <- TRUE
urchin %>%
  mutate(lgsk = log(!!x)) %>%
  summarise(mean = mean(lgsk,
    na.rm = !!na_rm))
```

Par rapport au cas précédent, nous devons créer explicitement une `quosure`, à l'aide de `quo()` ou `enquo()`. Pour le reste, le travail est le même.


#### Variable avec `quosure` dans `flow`

```{r}
flow(urchin,
  x_ = skeleton,
  na_rm = TRUE) %>_%
  mutate(., lgsk = log(x_)) %>_%
  summarise(., mean = mean(lgsk,
    na.rm = na_rm_)) %>_% .
```

Dans `flow`, l'opérateur suffixe `_` est utilisable également à l'assignation pour indiquer qu'on veut utiliser une expression à évaluer de manière non standard. Dans ce cas, `flow` créera la `quosure` de manière totalement transparente et fera le `unquote`ing dans l'expression non standard fournie à `mutate()`.



```{r}
flow(urchin,
  x_ = skeleton,
  y_ = log_skel,
  na_rm = TRUE) %>_%
  
  mutate(., y_ = log(x_)) %>_%
  summarise(., mean = mean(y_,
    na.rm = na_rm_)) %>_% .
```

L'équivalent en tidyverse pur donne (notez qu'il faut deux variables pour le nom `y_name` sous forme de chaine de caractères, puis l'appel de la nouvelle variable, `y` sous forme de `quosure`):

```{r}

x <- quo(skeleton)
y_name <- "log_skel"
y <- as.quosure(as.name(y_name))
na_rm <- TRUE
urchin %>%
  mutate(!!y_name := log(!!x)) %>%
  summarise(mean = mean(!!y,
    na.rm = !!na_rm))
```


